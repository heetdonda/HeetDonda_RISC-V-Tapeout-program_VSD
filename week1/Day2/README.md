# üìò Day 2 ‚Äî Timing, Synthesis Strategies & Flip-Flop Design

This document presents the **Day 2** content, emphasizing the importance of timing libraries, contrasting various synthesis methodologies, and examining best practices for writing efficient flip-flop RTL code.


---

## üïí Introduction to Timing Libraries (`.lib`)

### üìù Theory
A **timing library (`.lib`)** is an essential file in digital design. Provided by the semiconductor foundry, it describes the performance characteristics of all standard cells in a specific Process Design Kit (PDK).

**Main Features of a `.lib` File:**
- **Timing Data:** Includes gate propagation delays, flip-flop setup and hold times, and other timing arcs, usually in lookup tables based on input transition times and output load.
- **Power Information:** Specifies both leakage and dynamic power consumption for each cell under various conditions.
- **Cell Area:** Physical size of each standard cell.
- **PVT Corners:** Covers different **Process, Voltage, and Temperature (PVT)** scenarios (e.g., fast, slow, typical) to ensure reliable operation across all expected conditions.

Synthesis tools (like Yosys) and Static Timing Analysis tools (like OpenSTA) use `.lib` files to convert RTL into an optimized gate-level netlist and validate its timing performance.


---
## Lab on timeing libraries
1. To open netlist
   ```bash
   cd lib/
   gvim sky130_fd_sc_hd__tt_025C_1v80.lib
   ```

## üèóÔ∏è Hierarchical vs. Flat Synthesis

### üìù Theory
Synthesis converts high-level RTL into a gate-level netlist. The two main approaches are **flat synthesis** and **hierarchical synthesis**.

#### Flat Synthesis
**Flat synthesis** flattens the entire design hierarchy, treating the whole project as a single large module.  
- **Analogy:** Like dumping all the car‚Äôs parts‚Äînuts, bolts, panels‚Äîinto one pile and assembling it from scratch.  
- **Advantages:** Enables optimizations across the full design, often achieving the best timing and area results (**Quality of Results - QoR**).  
- **Disadvantages:** Very slow and memory-intensive, making it unsuitable for large designs like modern SoCs.

#### Hierarchical Synthesis
**Hierarchical synthesis** preserves the RTL hierarchy and synthesizes the design module by module.  
- **Analogy:** Building a car by assembling the engine, chassis, and interior separately, then combining them into the final car.  
- **Advantages:** Faster, uses less memory, and scales well for large teams working on different blocks concurrently.  
- **Disadvantages:** Module-level optimization may slightly reduce overall performance compared to flat synthesis.

For most complex modern designs, **hierarchical synthesis** is the preferred industrial standard.

---
## Lab on Flat and Hierarchical Synthesis

### üß™ Lab Steps
In this lab, we use a design with multiple modules. We will perform both **flat synthesis** and **hierarchical synthesis** on the same design to compare results.


### hirachical synthesis
1. open yosys
   ```bash
   yosys
   ```
2. synthesis code for hierarchical
   ```bash
   read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
   read_verilog multiple_modules.v
   synth -top multiple_modules 
   abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
   show multiple_modules
   ```
3. Output of the hierarchical synthesis
<img width="1649" height="1046" alt="hirachical_synthesis" src="https://github.com/user-attachments/assets/eb4b35f8-c685-4c29-b38c-93391b5badfe" />


### flatten synthesis
1. open yosys
   ```bash
   yosys
   ```
2. synthesis code for flatten
   ```bash
   read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
   read_verilog multiple_modules.v
   synth -top multiple_modules 
   abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
   flatten
   show 
   ```
3. Output of the hierarchical synthesis
<img width="1645" height="1047" alt="flatten_synthesis" src="https://github.com/user-attachments/assets/43b41ddd-d784-4307-b8cb-056ec00313d7" />


---
## üí° Flip-Flop Coding Styles and Optimization

### üìù Theory
Flip-flops serve as the basic storage elements in synchronous digital circuits. The Verilog coding style you choose directly impacts the hardware generated by the synthesis tool.

# üìò Synchronous vs. Asynchronous Inputs: Overview

This section offers a concise reference for understanding **synchronous** and **asynchronous** inputs in flip-flops and sequential logic designs.

---

## ‚è∞ Synchronous Inputs

A **synchronous** input can only affect a flip-flop's state on the active edge of a clock signal. This means the input's effect is synchronized with the system clock, ensuring predictable and stable behavior.

---

## Lab on synchronous dff
### Lab steps
1. Open gtkwave
   ```bash
   iverilog dff_syncres.v tb_dff_syncres.v 
   ./a.out
   gtkwave tb_dff_syncres.vcd
   ```
2. output gtkwave
<img width="1646" height="1044" alt="dff_syncronus_gtkwave" src="https://github.com/user-attachments/assets/828116bb-c041-4079-8050-674e9f166623" />


3. open yosys
   ```bash
   yosys
   ```
4. for synthesis
   ```bash
   read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
   read_verilog dff_syncres.v
   synth -top dff_syncres
   dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
   abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
   show
    ```
5. synthesis output
<img width="1647" height="1044" alt="syncronus_synthesis" src="https://github.com/user-attachments/assets/e520a6de-52cc-454a-a165-42fe0efda3c2" />


   
## ‚ö° Asynchronous Inputs

An **asynchronous input** changes a flip-flop‚Äôs state instantly, independent of the clock signal. It takes precedence over both the clock and synchronous data.

- **Asynchronous Set:** Instantly sets the flip-flop‚Äôs output to logic '1', ignoring the clock.


---
## Lab on asynchronous_set dff
### Lab steps
1. Open gtkwave
   ```bash
   iverilog dff_async_set.v tb_dff_async_set.v
   ./a.out
   gtkwave tb_dff_async_set.vcd
   ```
2. output gtkwave
<img width="1647" height="1042" alt="asyncronus_set_gtkwave" src="https://github.com/user-attachments/assets/2faa127f-9aaf-4f27-bbd7-581070d75a39" />


3. open yosys
   ```bash
   yosys
   ```
4. for synthesis
   ```bash
   read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
   read_verilog dff_async_set.v
   synth -top dff_async_set
   dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
   abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
   show
    ```
5. synthesis output
<img width="1648" height="1043" alt="asyncronus_set_synthesis" src="https://github.com/user-attachments/assets/e8b922e6-125a-44d2-b422-a93d54f4ec74" />



-   **Asynchronous Reset (or Clear):** The counterpart to set, this input immediately forces the flip-flop's output to a logic '0'.

---
## Lab on asynchronous dff
### Lab steps
1. Open gtkwave
   ```bash
   iverilog dff_asyncres.v tb_dff_asyncres.v
   ./a.out
   gtkwave tb_dff_asyncres.vcd
   ```
2. output gtkwave
<img width="1646" height="1044" alt="asyncronus_gtkwave" src="https://github.com/user-attachments/assets/2870787c-eb90-4e16-a5e0-89324def57de" />


3. open yosys
   ```bash
   yosys
   ```
4. for synthesis
   ```bash
   read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
   read_verilog dff_asyncres.v
   synth -top dff_asyncres
   dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
   abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
   show
    ```
5. synthesis output
<img width="1647" height="1044" alt="asyncronus_synthesis" src="https://github.com/user-attachments/assets/72d4859a-6d48-4c84-a20e-f0f0eb58b4c2" />


#### Optimization
Synthesis tools are best at handling standard, clean coding patterns. Using complex or unconventional logic for simple elements like flip-flops can result in inefficient hardware. Incorporating a **clock enable** is an effective optimization to save power by preventing the flip-flop from toggling on every clock cycle unnecessarily.

## Lab on Optimization: `mul_2`

### Lab steps
1. synthesis of mul_2
   ```bash
   yosys
   read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
   read_verilog mult_2.v
   synth -top mul2
   abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
   show
   ```
2. output synthesis
<img width="537" height="521" alt="mul_2 synthesis" src="https://github.com/user-attachments/assets/5a45748a-8cdd-4aab-8a2f-3e8c2845e40e" />

4. open netlist
   ```bash
   write_verilog -noattr mult2_net.v
   !gvim mul2
   ```
5. output of the netlist
<img width="969" height="626" alt="mul_2_netlist" src="https://github.com/user-attachments/assets/156b9ab9-1ba4-4eba-8ffd-8f1355fd2376" />


## Lab on optimaization mul_8
### Lab steps
1. synthesis of mul_8
   ```bash
   read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
   read_verilog mult_8.v
   synth -top mult8
   abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib 
   show
   ```
2. output synthesis
<img width="541" height="557" alt="mul_8 synthesis" src="https://github.com/user-attachments/assets/d5f71c30-44f6-48b0-836b-8d6ea06a3593" />

4. open netlist
   ```bash
   write_verilog -noattr mult8_net.v
   !gvim¬†mult8
   ```
5. output of the netlist
<img width="971" height="633" alt="mul_8_netlist" src="https://github.com/user-attachments/assets/d6fa9cd3-8ccc-4bff-adaf-0d111ed07ab3" />







